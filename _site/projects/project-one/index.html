<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.3 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Iannix + Csound: A Parametric Music System - Ben Ward - Audio DSP Developer</title>
<meta name="description" content="Iannix Iannix + Csound: A Parametric Music System  Project Overview">


  <meta name="author" content="Ben Ward">
  
  <meta property="article:author" content="Ben Ward">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Ben Ward - Audio DSP Developer">
<meta property="og:title" content="Iannix + Csound: A Parametric Music System">
<meta property="og:url" content="http://localhost:4000/projects/project-one/">


  <meta property="og:description" content="Iannix Iannix + Csound: A Parametric Music System  Project Overview">







  <meta property="article:published_time" content="2026-02-12T20:24:54-05:00">





  

  


<link rel="canonical" href="http://localhost:4000/projects/project-one/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Ben Ward - Audio DSP Developer Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>
    <script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    }
  };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <body class="layout--splash wide" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Ben Ward - Audio DSP Developer
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li><li class="masthead__menu-item">
              <a
                href="/plugins/"
                
                
              >Plugins</a>
            </li><li class="masthead__menu-item">
              <a
                href="/projects/"
                
                
              >Projects</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      

<div id="main" role="main">
  <article class="splash" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Iannix + Csound: A Parametric Music System">
    <meta itemprop="description" content="Iannix Iannix + Csound: A Parametric Music SystemProject Overview">
    
    

    <section class="page__content" itemprop="text">
      <h1 id="iannix-iannix--csound-a-parametric-music-system">Iannix Iannix + Csound: A Parametric Music System</h1>
<p><img src="/assets/images/iannix/IanniX_Capture_Mobius_Alt1.png" alt="Engaging Photo of Project" /></p>
<h3 id="project-overview">Project Overview</h3>

<p>This project explores the integration of IanniX’s visual graphing capabilities with Csound’s synthesis engine. The final result is a parametric music system which utilizes the contour lines of a 3D shape, programmed within the IanniX system, to inform oscillator parameters within a constrained musical system in Csound. The control capabilities within IanniX allow for the resulting composition to not only be a static, generative piece, but also an interactive system that encourages the user to distort the original parameters to explore the sonic relationships defined within the space.</p>

<p>When both systems are running, IanniX serves as an interactive visualization for the musical environment within Csound. As the piece develops, the user will see individual cursors moving along the contour lines defined in IanniX which each have mapped the x, y, and z parameters to distinct variables within the audio synthesis process.</p>

<h3 id="motivation">Motivation</h3>
<p>I’ve always been drawn to work that fuses multiple disciplines. Certain historical figures have excelled at this, and their unique expertise across seemingly incompatible subjects often expresses itself in unique and interesting ways. One of the most influentital figures of my own practice is Iannis Xenakis, an engineer, architect, and composer. His compositions are known for their graphic scores, which inform performers through visual interpretation rather than conventional notation. Many of his works were informed by mathmatical functions and stochastic processes, an approach that fascinated me as a compositional technique. Today, his legacy lives on in IanniX, a visual scoring system developed by Jean-Baptiste Thiebaut and collaborators which expounds on his ideas by allowing the user to create dynamic 3D scores that evolve and generate compositional data over time.</p>

<p>Learning of this program immediately piqued my interest, and I knew I wanted to do a project with it. The opportunity came during graduate school, when we were assigned to present on integrating third-party applications with Csound. I spent time learning the software and developed this project, the Möbius strip, as a demonstration piece for the presentation. It turned out compelling enough to warrant a full write-up.</p>

<h2 id="graphing-in-iannix">Graphing in Iannix</h2>
<p>In starting this project, I wasn’t sure exactly what the end goal would be. I wanted to utilize the 3D capabilities of IanniX, so I thought generating an interesting 3D shape would be a good way to get to know the program. I eventually decided on a Möbius strip as it would be a good challenge and I thought it would yield interesting visual and musical results.</p>

<h3 id="overview-of-iannix">Overview of IanniX</h3>
<p>IanniX scores generate data by making use of three primary graphing tools: <strong>lines</strong>, <strong>cursors</strong>, and <strong>events</strong>. The lines are simply lines defined somewhere in the 3D space and control where the cursors move along. The cursors represent the elements of the score that change continuously throughout time, and can be placed along lines to move across throughout the composition. The events can also be placed anywhere in 3D space, and are used to send binary trigger data, being triggered by cursors colliding with their definable boundary.</p>

<h1 id="generating-a-möbius-strip">Generating a Möbius Strip</h1>
<p>Since a Möbius Strip exists as a 2D plane within 3D space, modeling it in IanniX isn’t completely straightforward since IanniX is really only built for 1-dimensional lines/curves. My solution was to generate contour lines that would resemble a Möbius Strip when placed contiguously. This was a straightforward task since IanniX easily allows curves to be defined via parametric equations, and since a Möbius Strip is most aptly defined via parametric equations, this suited my situation perfectly.</p>

<h3 id="parametric-equations-in-iannix">Parametric Equations in IanniX</h3>
<p>The term <strong>Parametric</strong> can seem kind of daunting to an uninitiated listener; however, in the context of this program it becomes pretty straightforward. A parametric equation is one whose spatial coordinates (x, y, and z in our case) are defined by an outside variable, i.e., the coordinates aren’t inherently related via an x = y relationship. In IanniX, we are granted the ability to define a curve with independent functions for each coordinate, i.e., parametrically. We can use this to come up with interesting curves by simply combining simple or complex equations for each coordinate, independently. Furthermore, these equations can be written with <strong>params</strong>, which automatically create variable sliders which can be used to transform the resulting shape through the variable’s defined influence on the function throughout the performance.</p>

<p>If you are interested in trying this out for yourself, I’d recommend adding a <em>math curve</em> within the default curves in IanniX; this creates a sine wave shape across the x and y-axis. By selecting the curve and going to the info → 3D Space tab, you can see the equation that defines the curve in an editable box, along with <strong>params</strong> which are written into the equation. By playing around with this and editing it with some different equations, you can get a solid grasp of what parametric equations are, and how to utilize them within IanniX.</p>

<h3 id="mobius-strip-equation">Mobius Strip Equation</h3>
<p>The Mobius Strip can be defined by the parametric equations…</p>

\[\begin{aligned}
x(u,v) = (R + v\cos\frac{u}{2})\cos{u} \\
y(u,v)= (R + v\cos\frac{u}{2})\sin{u} \\
z(u,v)= v\sin\frac{u}{2} \\
\end{aligned}\]

<p>Each equation defines one of the dimensional coordinates for the Möbius strip, $x, y, z$. Since this is parametric, this is ideal for IanniX which expects a parametric equation. However, in order to draw this in IanniX, we need to breakdown this equation a bit further so we can isolate which variables we will need to parameterize in the equations.</p>

<p>We can try loading this equation straight into a curve within IanniX if we replace each variable $R, u, v$ with IanniX’s slider parameter keyword <strong>param</strong>. Here, <strong>param1</strong> will become the variable $R$, <strong>param2</strong> becomes $v$, and <strong>param3</strong> becomes $u$. Each variable has been scaled by $4\pi$ to create a complete effect.</p>

<p>( param1 * 3.14 * 4 + param2 * 3.14 * 4 * cos(param3 * 3.14 * 4 * t / 2) ) * cos(param3 * 3.14 * 4 * t)
,
( param1 * 3.14 * 4 + param2 * 3.14 * 4 * cos(param3 * 3.14 * 4 * t / 2) ) * sin(param3 * 3.14 * 4 * t)
,
param3 * 3.14 * 4 * sin(param1 * 3.14 * 4 * t / 2)</p>

<p>By adjusting the parameter values, we can generate a curve like the one shown below. <strong>Param1</strong> controls the radius of the Möbius strip, while <strong>param2</strong> and <strong>param3</strong> represent the parametric variables that evolve over time to define its shape. Sliding these parameters reveals how the Möbius strip-like form emerges from the curve boundaries. This insight provides our approach: by generating multiple curves with the same parametric equations but incrementally varied parameter values, we can create a series of contour lines that collectively outline a Möbius strip in 3 dimensions. However, manually creating and adjusting at least 20 individual curves would be tedious. Fortunately, IanniX’s script editor offers an efficient solution.
 <img src="/assets/images/iannix/Mobius_Line.png" alt="Single Mobius Strip Curve" /></p>

<h2 id="scripting-in-iannix">Scripting in Iannix</h2>
<p>Iannix provides a scripting editor in a javascript like languages with a series a built in commands to control Iannix parameters. These commands include generating curves, lines, triggers, and cursors; modifying their functions; and performing other more general operations. For this overview, I’ll avoid going into too much detail about the general scripting language and instead focus on what I did to generate the Mobius strip. More information on the scirpting commands can be found within the Iannix Software Documentation.</p>

<h3 id="mobius-function">mobius() Function</h3>
<p>Below shows a general function I came up with for creating the mobius strip. This can be run simply by placing within in the provided default function, <code class="language-plaintext highlighter-rouge">makeWithScript()</code>. There is some additional functionality included in this example, but most of those are self-explanatory, and are merely for aesthetics.</p>

<p>Most of the generation for the Möbius strip is happening within the <code class="language-plaintext highlighter-rouge">for</code> loop. To start, we need to know how many curves we are going to generate, and across what boundaries we want our strip to be defined. This is done with the <code class="language-plaintext highlighter-rouge">Num_Curves</code> variable. Here, <code class="language-plaintext highlighter-rouge">Num_Curves</code> is hard-coded into the script; however, it can optionally and usefully be loaded as a chosen variable by the user by adding it in the default <code class="language-plaintext highlighter-rouge">askUserForParameter()</code> function.</p>

<p><strong>The <code class="language-plaintext highlighter-rouge">v</code> variable</strong><br />
The variable we are going to iterate across to produce our strips is <code class="language-plaintext highlighter-rouge">v</code>. This is the same as the $v$ variable in the original Möbius equation, and will represent the width of the Möbius strip. Since this can also be a useful variable, it has been defined above with the other user variables, and added into the equation as parameter 5. We use this width variable to obtain the increment value for <code class="language-plaintext highlighter-rouge">v</code> by dividing the width by <code class="language-plaintext highlighter-rouge">Num_Curves</code>.</p>

<p>Within the for loop, we begin executing many of the <code class="language-plaintext highlighter-rouge">run("...")</code> commands that actually perform tasks within the IanniX program. First, a curve is created, along with an ID we increment thoughout the loop. The curve is then added to the ‘mobius’ group, and its position and size (which more closely corresponds to thickness for curve lines) are set.</p>

<p><strong>IDs and Groups</strong><br />
There are a few useful considerations to note when generating many functions like this. IanniX gives curves an ID number to help identify specific curves, added when generated. As well as this, objects can be added into groups that allow you to perform common operations on all group members at once. This is extremely useful for these cases where we are using 20+ curves for one specific function. Adding a curve to a group within the scripting is simple too; in this case, it is done with a single command: <code class="language-plaintext highlighter-rouge">run("setgroup current mobius");</code>, where <code class="language-plaintext highlighter-rouge">mobius</code> corresponds to a variable group name.</p>

<p><strong>setEquation()</strong> <br />
Finally we get to the <code class="language-plaintext highlighter-rouge">setEquation()</code> function, where the bulk of the interesting things are happening. The format for the <code class="language-plaintext highlighter-rouge">setEquation</code> command is</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setEquation current polar_flag x_equaiton, y_equation, z_equation
</code></pre></div></div>
<p>Since we have to set 3 complex equations within one line, we end up with the unwieldly looking command below…</p>

<p><code class="language-plaintext highlighter-rouge">setEquation current 0 (1 +" + v + "*param5*10*.5*cos(4*PI*t*2 * param1))*cos(t*4*PI*param2),(1 +" + v + "*param5*10*.5*cos(4*PI*t/2*param3))*sin(4*PI*t*param4)," + v +"*param5*10* 0.5 * sin(4*PI*t/2)</code></p>

<p>If we breakdown one of the equation commands, we can see how easily it maps onto the original mobius equation. The parametric equation for the x-dimension is as follows…</p>

\[x(u,v) = (R + v\cos\frac{u}{2})\cos{u} \\\]

<p>This becomes the following equation in the IanniX script.
<code class="language-plaintext highlighter-rouge">1 +" + v + "*param5*10*.5*cos(4*PI*t*2 * param1))*cos(t*4*PI*param2)</code></p>

<p>This is essentially a direct translation of the original equation, with some arbitrarily added parameters and added scaling.</p>
<ul>
  <li>The $R$ variable has been hardcoded as 1, though it could serve as an interesting control parameter.</li>
  <li>Our variable <code class="language-plaintext highlighter-rouge">v</code> is equivalent to the $v$ variable in the equation and is the key parametric value that we update in the loop.</li>
  <li>The variable <code class="language-plaintext highlighter-rouge">t</code> represents <em>time</em>, and IanniX automatically evaluates our curve equation throughout time to draw the curve; this also replaces the $u$ variable in the original equations.</li>
</ul>

<p>This covers all the variables from the original equation. The added scaling factors of 10 and <code class="language-plaintext highlighter-rouge">4*PI</code> are there to scale the parameter ranges to more useful/interesting values. These values were chosen mostly through trial and error; however, the <code class="language-plaintext highlighter-rouge">PI</code> values are specifically useful within a trigonometric operation (sin/cos) since it will map the [0,1] range to a complete cycle.</p>

<p><strong>Setting Cursors</strong><br />
After setting the equations for each of the curves, the last important step is to add cursors for the curves. This can be done easily by running the <code class="language-plaintext highlighter-rouge">add cursor</code> command, along with a unique ID. The cursors are then attached to the last curve created using the <code class="language-plaintext highlighter-rouge">setCurve</code> command and the <code class="language-plaintext highlighter-rouge">lastCurve</code> keyword. Additional cursor parameters can then be customized by utilizing the range of available <code class="language-plaintext highlighter-rouge">set____</code> commands: in this example, the colors of each cursor are slightly altered to create a unique color effect, and helps distinguish individual cursor positions when many are present.</p>

<p><strong>Setting Message Outputs</strong><br />
The final important command to note in this script is the <code class="language-plaintext highlighter-rouge">run("setmessage current 20, ...")</code> command. This command is useful for setting the types of message outputs you want to send over the OSC control. These controls can also be edited by selecting individual cursors within the main application interface. For this message, we specify the message type we want to send, pass the cursor ID, and then list the cursor data to transmit.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

</code></pre></div></div>
<p>function mobius2()
{
	//User Variables
	var Num_Curves = 25;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//width can also be controlled by parameter 5.
var width = 1;
var thickness = 1;
var id = 1;


//The main variable we use to sample across the mobius strip
var v = 0;
//The varaible we use to increment it
var incr = width/Num_Curves;



//Color Variables
var blue = 0;
var red = 0;
var c_incr = 255/Num_Curves;


//Main Loop: Adds a curve and cursor for each loop
for(var i = 0 ; i &lt;= Num_Curves ; i++){
	
	//Add Curve, set group, other parameters, equation
	run("add curve " + (id + i));
	run("setgroup current mobius");
	run("setPos 	current 0 0 0");
	run("setSize current " + thickness);
	run("setEquation current 0 (1 +" + v + "*param5*10*.5*cos(4*PI*t*2 * param1))*cos(t*4*PI*param2),(1 +" + v + "*param5*10*.5*cos(4*PI*t/2*param3))*sin(4*PI*t*param4)," + v +"*param5*10* 0.5 * sin(4*PI*t/2)");

	//Parameter Defaults
	run("setEquationParam current param1 0.25");
	run("setEquationParam current param2 1");
	run("setEquationParam current param3 1");
	run("setEquationParam current param4 1");
	run("setEquationParam current param5 0.1");
	
	//Set Cursor Parameter Defaults
	run("add cursor  " + (1001 + i));
	run("setCurve current lastCurve");
	run("setSpeed current .1");
	run("setPattern current 0 0 1");
	run("setGroup current cursors");
	run("setColor current 100 20 " + blue + " 255");
	run("setWidth current .05");
	run("setmessage current 20, osc://ip_out:port_out/cursor cursor_id cursor_value_x cursor_value_y cursor_value_z");

	//Incremement Variables
	v += incr;

	//Colors
	red += c_incr;
	blue += c_incr;
} }
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
By rending the script above, you should obtain a result similar to this.

![Mobius Script Render](/assets/images/iannix/Basic_Mobius_No_triggers.png)

This render was done with `Num_Curves = 50`; each of the 2D planes resting on the curve is a cursor. From here, we can perform the compostition by using the playback transport on the bottom of the screen. Using this, we can speed up and slow down the performance playback, controlling the at which all cursors move through their parametric curves. With a working system for creating meaningful data, we can now start exporting the data and using it to create interesting performances.


# Communicating with an Outisde Application
Iannix has a few available protocols for exporting data outside of the program including serial, MIDI, and UDP. This projecet uses OSC, as it is the most straightforward for communication between applications. To enable OSC communication in Iannix, you need to got to the `CONFIG` tab on the inspector panel, and select `ENABLE OSC`. From here, you need to select a network ID for your other application to connect to and enter the ID for that applications OSC network connect protocol. For this project, I used Csound as the audio engine, however this can be replcaed with any audio generation program that can receive OSC messages.

## Communicating with Csound
OSC communication in csound is done by using the `OSClisten` opcode, in conjunction with `OSCinit`. The init function is called along with the OSC network ID to create a variable handle to the network, this handle is then passed to any `OSClisten` opcode (or other OSC protol opcode) to identify the OSC port. 



## mobius.csd
This will be an attempt to breakdown what is happening in the .csd file without getting into too much Csound specifics. There are 3 instruments being used here: 2 of them are for retrieving data from the network (1 for the trigger data, 1 for the cursors), and the third one generates the actual audio. 

**Global Variables**\\
At the top of the file, there is a range of global variables being initialized. Their descriptions describe their purpose, however the most importants to make note of are the `\\Cursor Values`` arrrays. These arrays are initialized with space for each of the curves generated and will each hold a unique incoming data type (x-positoin, y-position, etc).


### instr 1
`instr 1` is responsible for retrieving the trigger data from the OSC network. Since the trigger data behaves much differently than the continous cursor data, a seperate instrument helps with clarity.

**OSCListen** \\
 The trigger data is retrived by using the opcode `OSClisten`. along with passing the global `giPortHandle` variable initialized at the beginning, we also. need to pass the speific message address, along with the expected message format. Iannix automatically provides 4 message address types, and in this case we simply use the provided `/trigger`. We then provide the expect data format: in Iannix, trigger data can be configured to send lots of different data about the trigger, however in this case we are simply sending the trigger ID, along with the trigger value (127 when on, 0 when off), thus we provide the format `ff`. Finally, we provide the variables which the retrieved values will be stored in: `ktid`, and `ktval`. 

 The rest of `instr 1` is dedicated to triggering a musical effect whenver the trigger occurs. Although the `OSClisten` opcode returns a trigger value to a k variable (in this case `kGotTrig`), however I found it was more stable using the `changed` opcode to trigger from the actual retrieved OSC value. When the trigger is triggered, the varaible `ktval` triggers the if statement below, performing the musical logic. For sake of brevity, I won't get into the details of this logic, but the overall intended effect is to trigger a random transposition of each oscillator every 2.1 cycles around the mobius strip. 

 ### instr 2

 `instr 2` is similar to `instr 1` in that it's purpose is to handle incoming data, however it requires a bit more precise programming to handle all of the incoming messages. Instead of collecting a single varaible from a single trigger, we now have to collect 5 different data parameters from possibly 50+ contious data curves. To solve this, we employ unique arrays for each variable, large enough to hold a parameter for each curve; we store data in order of the cursor ID's for ease of data management; and we use a loop for both retrieving messages, and storing them in thei respetive arrays.

 The first loop is done with Csound loop protocol `kgoto`. The OSClisten opcode is being called once every k-rate (default is every 48000/64 samples); everytime this happens, we need to retrieve all the updated messages from the OSC network. Because a lot of cursors will update during this time, we need to loop through all of the cursors to make sure we update all the data properly. This loop does that by using the `kGotIi` variable to check for new messages (it will be 1 whenever there is a new message), and if so, takes the data collected in the variables provided to the `OSClisten` opcode, and stores them in their respetive arrays. This repeats until there are no more new messages, in which case it exits.

 Finally, the retieved data is processed into a more meanigful format which will processed in `instr 3`.

 ### instr 3

 Finally, `instr 3` takes the data collected and parsed in `instr 1` and `instr 2`, and creates the audio landscape. The goal for this effect was to create simple sine wave oscillators for each individual curve, then use the x, y, and z positions of the cursors as frequency, amplitude, and some variable parameter. The main audio generator is the `oscili` opcode, which receives the amplitude data, processed frequency data, and a custom waveshape to produce a tone, 
 
 **Running an Instrument Loop** \\
 In order to create a unique oscillator for each curve, a loop was employed. However, creating a loop of unique audio rate instruments proved to be tricky in Csound,. The solution I found came from using a recursive loop via a `schedule` opcode. We can find this loop at the very bottom of `instr 3`.
 
</code></pre></div></div>
<p>if(p4 + 1 &lt; giNumBands) then
	schedule(3, 0, p3, p4+1)
endif</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
 By using this opcode to call itself, it will continually instantiate new instances of `instr 3`. Using 'p' variables, we send the new ID value to each new instrument instance, allowing it to close the loop once enough instruments have been run; this variable is also used to retrieve the appropriate cells from the arrays of positional data generated by Iannix. 
 
 **Audio Process** \\
 The actual audio processing happing in `instr 3` is relatively simple. First, the `oscili` opcode generates a sine wave using the processed amplitude and frequency data (The frequency data includes an extra processing step to detune certain frequencies based on the y-variable). The audo is then scaled down based on the number of total oscillators and a basic low-pass filter is applied, using more positional data to feed the frequency and resonance. Finally, the oscillators are panned across the stereo field evenly using the cursor ID. That is the entire audio generation process, however some more data processing was done to ensure oscillator frequencies were consonant. Mapping the cursor x-position to raw frequencies leads to a very dissonant jumble of noise; to make the piece more musical, position data intended for frequencies were first mapped onto a custom musical scale in the array: `giNotes[]`, which outlines an extended chord structure with alternating major and minor thirds, with an extra major second on top.
</code></pre></div></div>
<p>giNotes[] fillarray -3, 0, 4, 7, 11, 14, 16</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

 **Transposing via Trigger** \\
The trigger data collected in `instr 1` is used to create a random tranposition effect on the oscillators periodically throughout the performance. This is done by using the processed trigger signal in `instr 1` to generate a random value -3, and 3. This is stored in a global variable and retrieved within `instr 3`. Whenever the trigger signal is activated, this updates the new transposition value in `instr 3`, and this value is sent to all the oscillators, transposing the entire musical effect at the same time. A `portk` opcode was also added to created a glide between the new notes when a new transpostion occurs. 

**Score Editor** \\
 Lastly, we need to instruct our insruments to run when we press play. This is done by adding a score in the Score Editor. Note that instrument 3 requires an extra argument, p4, that represents our curve/instrument ID, which we pass a value of 0.

</code></pre></div></div>
<p>i1 0 1000
i2 0 1000
i3 0 1000 0</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

## Running the System
Once both files are properly settup, to run the complete performance with both applications, we simply need to press play in both the Iannix transport system and Csound. If OSC communication is properly settup, then we should be able hear our array of oscillators panned across the stereo field, shifting notes in seemingly random ways. 

**Debugging Communication Issues**
If the Csound file plays, but the tones are static, then this means it isn't receiving the data from Iannix. If this happens, ensure both Iannix and the `OSCInit` opcodes using the same host network; sometimes the OSC system in CSound can be a little buggy, so it can be useful to use an OSC monitoring application for debugging. 

### Interacting with the Performance
Now that the performance is running, we can use the `param_` varaibles implemented in the mobius strip equation to alter both the visual shape being displayed, and the data that is being sent to Csound, thus altering the produced sound. In Iannix, under `Inspector-&gt;Objects`, we can select our group of cursors, then go to the `info` tab of the inspector to gain access to our parameter sliders. By moving these sliders, we update the variables within our written equation and Iannix will in turn update the curves and cursors. By incorperating 5 different parameters, we can mangle the shape in a lot of interesting ways, creating a unique visual, and audio effect.
![Image of Iannix Params](/assets//images/iannix/Iannix_Parameters.png)


**Note:** Changing parameters will cause the OSC data to update immediately, likely causing harsh jumps in the audio output. The best way to solve this issue is by using an opcode like `portk` for smoothing out harsh changes within the Csound audio process, and not try and buffer or delay the OSC messages unless you are specifcally looking for a lower resolution in the OSC message commmunication.

Below are some of the visual results from experiments with changing the parameters
![Iannix Output wiht New Params](/assets/images/iannix/IanniX_Capture_Mobius_Alt1.png)

### Moving Cursors
Another useful feature of Iannix, especially for this project, is the ability to set cursor start positions. Within a cursor's settings in the inspector, we can alter some the time based behavior of individual cursors. This is great for creating variance between cursors which are folowing similar paths. 

![Iannix Cursor Time Settings](/assets/images/iannix/Iannix_Cursor_Time_Settings.png)

Along with the inspector panel, we can also set these options within the script editor. For instance, in this project, when each cursors starts at the same position, the generated audio is almost identical for each oscillator. While it is interesting to hear the subtle detuning that happens as these cursors diverge, we might want a more chaotic result right off the bat. We can use the script editor to offset the starting position of these cursors at the beginning of the performance. For this example, I simply used of the increment variables to add to an offset variable. On each loop pass, this variable is increment by an arbitrary value, then the following command is run.
</code></pre></div></div>
<p>run(“setoffset current “ + offset + “ 0 0”);
```
The result is the same mobius curve pattern, with each cursor beginning in random places throughout the curve. 
<img src="/assets/images/iannix/Iannix_Distributed_Cursors.png" alt="Mobius with Offset Cursors" /></p>

<h2 id="conclusion">Conclusion</h2>
<p>The purpose of this project was to experiment with Iannix and explore the capabillities of using a graphical data system to control an audio engine, and specifically Csound. I found the project very successful in coming up with an interesting visual, and musical performance. Learning Iannix was pretty straightforward, and I didn’t have any major issues learning or working with the script editor. The biggest challenge in this project was configuring Csound to properly retrieve OSC data from Iannix. Since there is a lot of contious data being transmitted, it took a loop and array storage to properly handle, but having a working example now should help future enthusiasts.</p>

<p>After the hurdles however, the project produced a really intersting performance system. I found using a loop to draw curves outline a 3D shape to be very interesting as both a visual effect, and as a source of musical data. The ability to program params into the parametric equations also created some unexpected consequences: being able to alter the parametric curves in real-time allow the Iannix program to go from being a static composition tool, to a live performance system, and I’m very intersted in extending this project for a more live based application.</p>

<p>Csound proved to a be an effective audio application. Retrieving the OSC data was tricky, however now that there is a working example, it should be straightforward to connect any synthesis technique available in Csound with data transmitted from Iannix. This project uses very basic opcodes from Csound, focusing on the addition of many simple tones to create its effect. However there are many ways the audio process could be extended within Csound as Csound contains opcodes for virtually any synthesis process.</p>

<p>The combination of Iannix and Csound provides unique and engaging system for both the performer and audience. If you have any interest in digital audio, data sonification, and/or 3D visuals, I’d highly recommend these systems out for yourself.</p>

<h1 id="gallery">Gallery</h1>


    </section>
  </article>
</div>

      
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        

<div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>


<div class="page__footer-copyright">&copy; 2013 - 2026 <a href="http://localhost:4000">Ben Ward - Audio DSP Developer</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>









  </body>
</html>
